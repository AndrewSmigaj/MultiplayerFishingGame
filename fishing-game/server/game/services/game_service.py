import logging
import random
import time # Or use socketio.sleep
from typing import List, Optional, Dict

# Import the main socketio object to start background tasks
# This creates a potential circular import if app imports GameService directly.
# A common pattern is to pass socketio into GameService during initialization,
# or use Flask's app context or a dedicated task manager.
# We will pass socketio instance during initialization to avoid circular import.
# from ...app import socketio # REMOVE THIS IMPORT

# Import models, managers, repositories, and exceptions
from ...core.models import Player, Fish, Position
from ..managers.player_manager import PlayerManager
from ..managers.fish_manager import FishManager
from ...database.repositories.player_repository import PlayerRepository # Assuming Player data persistence
# from ...database.repositories.fish_repository import FishRepository # If fish state needs persistence
from ..exceptions import PlayerNotFoundException, InvalidActionException # Removed FishNotFoundException for now
# Import the new manager
from ..managers.fishing_manager import FishingManager

log = logging.getLogger(__name__)

class GameService:
    """
    Orchestrates game logic by coordinating managers and repositories.
    This is where high-level game actions are implemented.
    """

    def __init__(
        self,
        player_manager: PlayerManager,
        fish_manager: FishManager,
        fishing_manager: FishingManager, # Add FishingManager
        player_repository: PlayerRepository, # Inject dependencies
        socketio_instance # Add socketio instance parameter
        # fish_repository: Optional[FishRepository] = None # Optional persistence for fish
    ):
        self.player_manager = player_manager
        self.fish_manager = fish_manager
        self.fishing_manager = fishing_manager # Store FishingManager
        self.player_repository = player_repository
        self.socketio = socketio_instance # Store the instance
        # self.fish_repository = fish_repository
        # Dictionaries are now in FishingManager
        log.info("GameService initialized.")
        # Spawning fish is now handled by FishingManager if needed, or keep here? Let's keep here for now.
        self.fish_manager.spawn_initial_fish()

    def handle_player_connect(self, sid: str, player_name: str) -> Player:
        """
        Handles logic when a new player connects.
        - Checks if player exists in DB, creates if not.
        - Adds player to the in-memory PlayerManager.
        """
        log.info(f"Handling connection for SID: {sid}, Name: {player_name}")
        # Check if player exists by name (simple approach for now)
        player = self.player_repository.get_by_name(player_name)
        if not player:
            log.info(f"Player '{player_name}' not found in DB, creating new player.")
            # Create a new player instance (ID is generated by model)
            player = Player(name=player_name)
            # Persist the new player
            player = self.player_repository.create(player) # Get the persisted version back
        else:
            log.info(f"Existing player '{player_name}' found (ID: {player.id}).")

        # Add player to the in-memory manager for the current session
        self.player_manager.add_player(sid, player)
        return player

    def handle_player_disconnect(self, sid: str) -> Optional[Player]:
        """Handles logic when a player disconnects."""
        log.info(f"Handling disconnection for SID: {sid}")
        # Clear any active fishing attempt via FishingManager *before* removing the player
        self.fishing_manager.clear_fishing_attempt(sid) # Safe to call even if not fishing

        player = self.player_manager.remove_player(sid)
        if player:
            # Optional: Update player state in DB on disconnect (e.g., save position)
            # self.player_repository.update(player.id, {"position": player.position.dict()})
            log.info(f"Player {player.name} ({player.id}) removed from active session.")
            return player
        return None

    def handle_player_move(self, sid: str, new_position_data: dict) -> Optional[Player]:
        """Handles player movement updates."""
        player = self.player_manager.get_player_by_sid(sid)
        if not player:
            log.warning(f"Received move update for unknown SID: {sid}")
            return None # Or raise PlayerNotFoundException(sid) depending on desired strictness

        try:
            new_position = Position(**new_position_data)
            updated_player = self.player_manager.update_player_position(sid, new_position)
            log.debug(f"Player {player.name} moved to {new_position.x}, {new_position.y}")
            return updated_player
        except Exception as e: # Catch Pydantic validation errors etc.
             log.error(f"Invalid position data received for SID {sid}: {new_position_data} - Error: {e}")
             return None # Or raise InvalidActionException

    def handle_player_face(self, sid: str, data: dict) -> Optional[Player]:
        """Handles player changing direction."""
        player = self.player_manager.get_player_by_sid(sid)
        if not player:
            log.warning(f"Received face update for unknown SID: {sid}")
            raise PlayerNotFoundException(sid) # Raise exception as client expects a response or error

        direction = data.get('direction')
        if not direction or direction not in ["up", "down", "left", "right"]:
            log.warning(f"Invalid direction data received for SID {sid}: {data}")
            raise InvalidActionException(f"Invalid direction specified: {direction}")

        # PlayerManager handles the actual update and validation
        updated_player = self.player_manager.update_player_direction(sid, direction)
        if updated_player:
            log.debug(f"Player {player.name} faced {direction}")
            return updated_player
        else:
            # This case might happen if the direction string was somehow invalid despite the check above,
            # or if the player disappeared between checks (less likely).
            log.error(f"Failed to update direction for player {player.name} ({sid}) even after validation.")
            # Consider raising an internal error or just returning None/raising InvalidActionException
            raise InvalidActionException("Failed to update player direction.")


    def get_world_state(self, requesting_sid: str) -> dict:
        """Gets the current state of the world (other players, fish)."""
        # Could be optimized later (e.g., spatial partitioning)
        other_players = self.player_manager.get_other_players(requesting_sid)
        all_fish = self.fish_manager.get_all_fish()
        return {
            "players": [p.dict() for p in other_players],
            "fish": [f.dict() for f in all_fish]
        }

    # _calculate_cast_endpoint MOVED to FishingManager
    # _get_spot_id MOVED to FishingManager

    def handle_start_cast(self, sid: str, cast_data: dict) -> Optional[Dict]:
        """
        Handles the start_cast event from a client.
        Checks player state, spot occupation, calculates endpoint, updates state,
        and potentially starts the hook check loop.
        Returns dict with cast details if successful, None otherwise.
        """
        player = self.player_manager.get_player_by_sid(sid)
        if not player:
            log.warning(f"handle_start_cast called for unknown SID: {sid}")
            raise PlayerNotFoundException(sid)

        # Delegate the core logic, including state checks, to the FishingManager
        # FishingManager will raise exceptions (like InvalidActionException) on failure
        return self.fishing_manager.start_fishing_attempt(sid, cast_data)

    # clear_fishing_attempt MOVED to FishingManager

    def cast_line(self, sid: str, target_position_data: dict):
        """DEPRECATED - Logic moved to handle_start_cast"""
        player = self.player_manager.get_player_by_sid(sid)
        if not player:
            raise PlayerNotFoundException(sid)

        try:
            target_position = Position(**target_position_data)
            log.info(f"Player {player.name} ({sid}) casting line towards {target_position}")
            # TODO: Implement line casting logic:
            # 1. Calculate line trajectory/end point based on player pos and target.
            # 2. Check for nearby fish at the line's end point using fish_manager.find_nearby_fish.
            # 3. Determine if a fish bites (random chance based on rarity, bait?).
            # 4. If bite, trigger minigame state for the player (emit event).
            # 5. Emit event to all players showing the cast line visually.
            pass # Placeholder
        except Exception as e:
            log.error(f"Invalid target position data for cast_line from SID {sid}: {target_position_data} - Error: {e}")
            raise InvalidActionException("Invalid target position for casting line.") from e

    def handle_minigame_update(self, sid: str, minigame_data: dict):
        """Handles updates from a player during the fishing minigame."""
        player = self.player_manager.get_player_by_sid(sid)
        if not player:
            raise PlayerNotFoundException(sid)

        log.debug(f"Received minigame update from {player.name} ({sid}): {minigame_data}")
        # TODO: Implement minigame logic:
        # 1. Validate input data.
        # 2. Update minigame state associated with the player.
        # 3. Check for success/failure conditions.
        # 4. If success:
        #    - Remove the fish using fish_manager.remove_fish.
        #    - Add fish to player's inventory (update player model).
        #    - Persist player inventory change via player_repository.
        #    - Emit success event to player.
        #    - Emit fish caught event to other players.
        # 5. If failure:
        #    - Emit failure event to player.
        #    - Fish potentially escapes (remains or despawns).
        pass # Placeholder

    # --- Game Loop Tick (Optional) ---
    def tick(self, delta_time: float):
        """Represents a single game loop tick for server-side updates."""
        # This would be called periodically if needed for server-side simulation
        # Example: Update fish positions
        # self.fish_manager.update_fish_positions(delta_time)
        # Example: Spawn new fish periodically
        # if random.random() < 0.01: # Example spawn chance
        #     self.fish_manager.spawn_fish("CommonFish", "Common", 10.0)
        #     # Need to notify clients about new fish
        pass # Placeholder for game loop logic

    # hook_check_loop MOVED to FishingManager

    def handle_cancel_cast(self, sid: str):
        """Handles a player's request to cancel their fishing attempt."""
        player = self.player_manager.get_player_by_sid(sid)
        if not player:
            raise PlayerNotFoundException(sid)

        # Delegate the cancellation logic to the FishingManager
        # Note: FishingManager's method is called cancel_fishing, which is fine.
        self.fishing_manager.cancel_fishing(sid)
